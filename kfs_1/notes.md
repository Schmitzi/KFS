# KFS_1 - Complete Learning Notes & Documentation

This document contains all the learning materials, tutorials, and detailed explanations used while building the KFS_1 kernel. This is for personal reference and deep learning.

**For the project README, see:** [README.md](README.md)

---

## Table of Contents

- [Project Overview](#project-overview)
  - [Introduction](#introduction)
  - [Objectives](#objectives)
  - [Instructions](#instructions)
  - [Compilation](#compilation)
  - [Mandatory Requirements](#mandatory)
  - [Bonus Features](#non-mandatory-part)
- [Knowledge Base](#knowledge-dump)
- [Rust Bare-Metal Tutorial](#freestanding-rust-binary)
- [Learning Resources](#sources--learning-resources)

---

# Project Overview

## Introduction

This is it. Kernel From Scratch. We are actually building a kernel without any existing 
software, API or anything

There are many parts to this project and they are all linked together. So as we build these
features, keep in mind that the kernel must be flexible and that functions must easily fit 
in. Half of the time you'll spend on these projects will be adding links between different
aspects of your kernel.

That means, you have to write memory code before processus & execution code. But processus
must use memory, right? So those two have to be linked! That means, keep it ***clean***,
and the internal API simple.

# Objectives

By the end of this journey, you will have:

- A kernel you can boot via ```GRUB```
- An ```ASM``` bootable base
- A basic kernel library, with basic functions and types
- Some basic code to print some stuff on the screen
- A basic "Hello World' kernel

# Instructions

## Code and Execution

It is advised to use ```KVM```, the Kernel Virtual Manager. It has advanced execution and
debug functions.

## Language

Kernel From Scratch allows you to pick your own language. Although te current kernel is
mostly C, you are free to build it in whatever you want. So of course we picked Rust ü¶Ä

Do remember that because there is a lot of documentation in C, we want to take on this
challenge of 'code translation'. Also, we are not allowed to use any of the language 
features in a basic kernel. For instance, C++ uses 'new' to make allocation, class and
structure declaration. We do not have a memory interface (yet).

# Compilation

## Compilers

We will be using cargo to make our kernel

## Flags

There are several flags that need to be used. In C++ they are:
- -fno-builtin
- -fno-exception
- -fno-stack-protector
- -fno-rtti
- -nostdlib
- -nodefaultlibs

The kernel will be compiled on a host system but cannot be linked to any existing library
on that host.

## Linking

You cannot use an existing linker in order to link your kernel. As written above, your kernel will not boot. That means we have to create a linker for your kernel.

***BEWARE*** you CAN use the 'ld' binary available on your host, but you CANNOT use there .ld file of your host

## Architecture

Its mandatory to build an i386 (x86) architecture

## Documentation

Check out the [OSDev](http://wiki.osdev.org/Main_Page) wiki

# Mandatory

## Base

The kernel must be able to boot with ```GRUB```, that can write characters on screen.

That means we have to:

- Install ```GRUB``` on a virtual image
- Write an ```ASM``` boot code that handles multiboot header, and use ```GRUB``` to
init and call the main function of the kernel itself.
- Compile it with correct flags, and link it to make it bootable
- Write helpers like kernel types or basic functions (strlen, strcmp, ...)
- Must be smaller than 10MB
- Code the interface between the kernel and the screen.
- Display "42" on the screen

For the linker, you must create a linker file with the [GNU linker (ld)](http://www.math.utah.edu/docs/info/ld_3.html#SEC4). 

## Makefile

The Makefile must compile all the source files with the right flags and the right compiler.
Keep in mind that the kernel will use at least two different languages (ASM and Rust), so
make sure the Makefile rules are correct

After compilation, all of the objects must be linked together in order to create the final
Kernel binary (Cf. Linker part)

# Non Mandatory part

This part is not necessary but will be implemented:

- Add scroll and cursor support to the I/O interface.
- Add colors support to the I/O interface.
- Add helpers like printf/printk to print and debug easier.
- Handle keyboard entries (interupts) and print them.
- Handle different screen and keyboard shortcuts to switch easily between them.

# Knowledge Dump

## What is a Kernel

The kernel is the hidden piece of the operating system that enables any other programs to execute. It handles events generated by hardware (called ``interupts``) and software (called system calls), and manages access to resources.

The hardware event handlers (interrupt handlers) will for instance get the number of key you just pressed, and convert it to the corresponding character stored in a buffer so some program can retrieve it.

The system calls are initiated by user-level programs, for opening files, starting other programs, etc. Each system call handler will have to check whether the argument  passed are valid, then perform the internal operation to complete the request.

Most user programs do not directly issue system calls (except for ```ASM``` programs, for instance), but instead use a ```standard library``` which does the ugly job of formatting arguments as required by the kernel and generating the system call (For example, the C function ```fopen()``` eventually calls a kernel function that actually opens the file)

The kernel usually defines a few ```abstractions``` like files, processes, sockets, directories, etc. which correspond to an internal state it remembers about last operations, so that a program may issue a session of operation more efficiently.

# Freestanding Rust Binary

[Introduction](#introduction)
[Disabling the Standard Library](#disabling-the-standard-library)
[The no_std Attribute](#the-no_std-attribute)
[Panic Implementation](#panic-implementation)
[Disabling Unwinding](#disabling-unwinding)
[What do you do without a main()?](#what-do-you-do-without-a-main)
[Linker Errors](#linker-errors)
[Building for a Bare Metal Target](#building-for-a-bare-metal-target)
[End Result](#end-result)

## Introduction
So the first real step we will take is creating a Rust executable that does not link to the standard library. That way we can run Rust code on ```bare metal``` without an underlying operating system.

This means we will not have threadsm files, heap memory, the network, random numbers, standard output or any features requiring OS abstractions or specific hardware. We have to make all of these on our own.

However, there are some functions we can use. For example, we can use iterators, closures, pattern matching, option and result, string formatting and the ownership system. These features make it possible to write a kernel in a very expressive, high level way without worrying about undefined behavior or memory safety.

All of this means we need to create a freestanding or bare metal executable.

## Disabling the Standard Library
By default, all Rust crates link the standard library, which depends on the operating system for features such as threads, files, or networking. It also depends on the C standard library libc, which closely interacts with OS services.

We create a new cargo application like this

```bash
cargo new kfs --bin --edition 2024
```

To break that down:
- kfs - name of the crate
- --bin - specifies that we want to create an executable binary (not a library)
- --edition 2024 - specifies that we want to use the 2024 edition of Rust for our crate

Our structure
```bash
kfs
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ main.rs
```

The Cargo.toml contains the crate configuration, for example the crate name, the author, the semantic version number, and dependencies.

The src/main.rs file contains the root module of our crate and our main function. You can compile your crate through ```cargo build``` and them run the compiled ```kfs``` binary in the ```target/debug``` subfolder.

## The no_std Attribute

As it stands, our crate links the standard library

We can disable that by chaning the src/main.rs file like so

```bash
#![no_std]  <- Add this

fn main() {
    println!("Hello, world!");
}
```

You'll now see this when you run cargo build

![firstcrash](/imgs/firstcrash.png "FirstCrash")

By removing the println! we get

![secondcrash](/imgs/secondcrash.png "SecondCrash")i

## Panic Implementation

The panic_handler attribute defines the function that the compiler should invoke when a panic occurs. The standard library provides its own panic handler function, but in a no_std enviroment we have to define it ourselves.

```bash
use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
```

The PanicInfo parameter contains the file and line where the panic happened and the optional panic message. The function should never return, so it is marked as a diverging function by returning the ‚Äúnever‚Äù type !. There is not much we can do in this function for now, so we just loop indefinitely.

## Disabling Unwinding

There are several reasons to do this so Rust gives us an option to disable it. We just need to add these to out Cargo.toml

```bash
[profile.dev]
panic = "abort"

[profile.release]
panic = "abort"
```
This sets the panic strategy to abort for both the dev and the release profile.

## What do you do without a main()?

A main function is the entrypoint to a program and is the stepping off point for all further execution. However most languages have a runtime system, which is responsible for things such as garbage collection or software threads. This runtime needs to be called before main() to initialize itself.

In a typical binary with stdlib, execution starts in a C runtime library called ```crt0``` (C runtime zero), which sets up the environment for a C application. this includes creating a stack and placing the arguments in the right registers. The C runtime then invokes the entry point of the Rust runtime, which is marked by the start language item. Rust only has a very minimal runtime, which takes care of some small things such as setting up stack overflow guards or printing a backtrace on panic, The runtime them finally calls the main function.

We dont have access to a runtime or crt0, so we need to define out own entry point. Implementing the start language item wouldn't help, since it would still require crt0. Instead, we need to overwrite the crt0 entry point directly.

## Overwriting the Entry Point

To do this we tell the Rust compiler that we dont want to use the normal entry point chain, we add the #![no_main] attribute

```bash
#![no_std]
#![no_main]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
```

Is is the entire function. It doesn't make sense to have a main function without the underlying runtime that calls it. Now we need to make our own _start function

```bash
#[unsafe(no_mangle)]
pub extern "C" fn _start() -> ! {
    loop {}
}
```

By using this attribute, we disable name mangling to ensure that the Rust compiler really outputs a function with the name _start. Without the attribute, the compiler would generate some cryptic symbol to give every function a unique name. the attribute is required because we need to tell the name of the entry point function to the linker in the next step.

Marking the function as extern 'C' tells the compiler that it should use the C calling convention for this function (instead of the Rust calling convention)

The ! return type means that the function is diverging, i.e. not allowed to ever return. This is required because the entry point is not called by any function, but invoked directly by the operating system or bootloader. So instead of returning, the entry point should e.g. invoke the exit system call of the operating system. in our case, shutting down the machine could be a reasonable action, since there's nothing left to do if a freestanding binary returns. For now, we fulfill the requirement by looping endlessly.

Running cargo build now gives us:

![linking](/imgs/linking.png "Linking")

## Linker Errors

The linker is a program that combines the generated code into an executable. Since the executable format differs between Linux, Windows, and macOS, each system has its own linker that throws a different error. The fundamental cause of the errors is the same: the default configuration of the linker assumes that our program depends on the C runtime, which it does not.

To solve the errors, we need to tell the linker that it should not include the C runtime. We can do this either by passing a certain set of arguments to the linker or by building for a bare metal target.

## Building for a Bare Metal Target

By defualt, Rust tries to build an executable that is able to run in your current system environment, For example, if you are using Windows on x86_64m Rust tries to build a .exe Windows executable that uses x86_64 instructions. This environment is called your "host" system

To describe different environments, Rust uses a string called target triple. You can see the target triple for your host system by running

```bash
rustc --version --verbose
```
![targettriple](/imgs/targettriple.png "Target Triple")

The above output is from a x86_64 Linux system. We see that the host triple is x86_64-unknown-linux-gnu, which includes the CPU architecture (x86_64), the vendor (unknown), the operating system (linux), and the ABI (gnu).

By compiling for our host triple, the Rust compiler and the linker assume that there is an underlying operating system such as Linux or Windows that uses the C runtime by default, which causes the linker errors. So, to avoid the linker errors, we can compile for a different environment with no underlying operating system.

```bash
rustup run nightly cargo build -Z build-std=core --target i386-unknown-none.json
```

By passing a --target argument we cross compile our executable for a bare metal target system. Since the target system has no operating system, the linker does not try to link the C runtime and our build succeeds without any linker errors.

This is the approach that we will use for building our OS kernel. We will use a custom target that describes a x86_64 bare metal environment. The details will be explained in the next post.

Alternatively we can compile with linker arguments

```bash
cargo rustc -- -C link-arg=-nostartfiles
```

## End Result

A minumal freestanding Rust binary looks like this:

src/main.rs:

```bash
#![no_std]
#![no_main]

use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}

#[no_mangle]
pub extern "C" fn kernel_main() -> ! {
    // Your kernel code here
    loop {}
}
```

Cargo.toml

```bash
[package]
name = "crate_name"
version = "0.1.0"
authors = ["Author Name <author@example.com>"]

# the profile used for `cargo build`
[profile.dev]
panic = "abort" # disable stack unwinding on panic

# the profile used for `cargo build --release`
[profile.release]
panic = "abort" # disable stack unwinding on panic
```

# A Minimal Rust Kernel

[The Boot Process](#the-boot-process)
[Bios Boot](#bios-boot)
[The Multiboot Standard](#the-multiboot-standard)
[Why do I need a Cross Compiler?](#why-do-i-need-a-cross-compiler)

## The Boot Process

When you turn on a computer, it begins executing firmware code that is stored in motherboard ROM. This code performs a power-on self-test, detects available RAM, and pre-initializes the CPU and hardware. Afterwards, it looks for a bootable disk and starts booting the operating system kernel.

On x86, there are two firmware standards: the ‚ÄúBasic Input/Output System‚Äú (BIOS) and the newer ‚ÄúUnified Extensible Firmware Interface‚Äù (UEFI). The BIOS standard is old and outdated, but simple and well-supported on any x86 machine since the 1980s. UEFI, in contrast, is more modern and has much more features, but is more complex to set up.

## Bios Boot

Almost all x86 systems have support for BIOS booting, including newer UEFI-based machines that use an emulated BIOS. This is great, because you can use the same boot logic across all machines from the last century. But this wide compatibility is at the same time the biggest disadvantage of BIOS booting, because it means that the CPU is put into a 16-bit compatibility mode called real mode before booting so that archaic bootloaders from the 1980s would still work.

When you turn on a computer, it loads the BIOS from some special flash memory located on the motherboard. The BIOS runs self-test and initialization routines of the hardware, then it looks for bootable disks. If it finds one, control is transferred to its bootloader, which is a 512-byte portion of executable code stored at the disk‚Äôs beginning. Most bootloaders are larger than 512 bytes, so bootloaders are commonly split into a small first stage, which fits into 512 bytes, and a second stage, which is subsequently loaded by the first stage.

The bootloader has to determine the location of the kernel image on the disk and load it into memory. It also needs to switch the CPU from the 16-bit real mode first to the 32-bit protected mode, and then to the 64-bit long mode, where 64-bit registers and the complete main memory are available. Its third job is to query certain information (such as a memory map) from the BIOS and pass it to the OS kernel.

## The Multiboot Standard

To avoid that every operating system implements its own bootloader, which is only compatible with a single OS, the Free Software Foundation created an open bootloader standard called Multiboot in 1995. The standard defines an interface between the bootloader and the operating system, so that any Multiboot-compliant bootloader can load any Multiboot-compliant operating system. The reference implementation is GNU GRUB, which is the most popular bootloader for Linux systems.

- To make a kernel Multiboot compliant, one just needs to insert a so-called Multiboot header at the beginning of the kernel file. This makes it very easy to boot an OS from GRUB. However, GRUB and the Multiboot standard have some problems too:
- They support only the 32-bit protected mode. This means that you still have to do the CPU configuration to switch to the 64-bit long mode.
- They are designed to make the bootloader simple instead of the kernel. For example, the kernel needs to be linked with an adjusted default page size, because GRUB can‚Äôt find the Multiboot header otherwise. Another example is that the boot information, which is passed to the kernel, contains lots of architecture-dependent structures instead of providing clean abstractions.
- Both GRUB and the Multiboot standard are only sparsely documented.
- GRUB needs to be installed on the host system to create a bootable disk image from the kernel file. This makes development on Windows or Mac more difficult.

This being said we are going to be adding GRUB and the Multiboot standard

## Why do I need a Cross Compiler?

You need to use a cross-compiler unless you are developing on your own operating system. The compiler must know the correct target platform (CPU, operating system), otherwise you will run into trouble. You may be able to use the compiler that comes with your system if you pass a number of options to beat it into submission, but this will create a lot of completely unnecessary problems.

It is possible ask your compiler what target platform it is currently using by calling the command: 

```bash
gcc -dumpmachine
```

![dumpmachine](/imgs/dumpmachine.png "Dump Version")

This is not suitable for osdev work, as this compiler will produce programs for Linux, and your operating system is not Linux, no matter how similar it is. You will certainly run into trouble if you don't use a cross-compiler.

# Writing a Bootloader

1. [What is Multiboot?](#what-is-multiboot)
2. [Assembly Language Basics](#assembly-language-basics)
3. [The Multiboot Header Explained](#the-multiboot-header-explained)
4. [The Stack Explained](#the-stack-explained)
5. [Boot Code Walkthrough](#boot-code-walkthrough)
6. [Learning Resources](#learning-resources)

---

## What is Multiboot?

**The Problem:**
Every OS needs a bootloader to load it into memory and start execution. Without a standard, every OS would need its own custom bootloader.

**The Solution:**
Multiboot is a **specification** (a set of rules) created by the GNU project that says:
- "If your kernel has THIS specific header..."
- "...then ANY Multiboot-compliant bootloader (like GRUB) can load it"

**What GRUB Does:**
1. GRUB scans the first 8KB of your kernel file
2. Looks for the magic number `0x1BADB002`
3. Reads the Multiboot header to understand what the kernel needs
4. Loads the kernel into memory at address 1MB (0x00100000)
5. Switches CPU to 32-bit protected mode
6. Jumps to your kernel's entry point (`_start`)

---

## Assembly Language Basics

### What is Assembly?
Assembly is the lowest-level human-readable programming language. It maps almost 1:1 with CPU machine instructions.

### Key Assembly Concepts:

**Registers** - Small, super-fast storage inside the CPU:
- `ESP` = Stack Pointer (points to top of stack)
- `EAX`, `EBX`, `ECX`, `EDX` = General purpose registers
- `EIP` = Instruction Pointer (points to next instruction to execute)

**Instructions:**
- `mov dest, src` = Copy data from src to dest
- `call function` = Jump to a function (saves return address)
- `jmp label` = Unconditional jump to label
- `cli` = Clear Interrupts (disable interrupts)
- `hlt` = Halt CPU until next interrupt

**Directives** (assembler commands, not CPU instructions):
- `section .text` = Start a code section
- `dd value` = Define Double-word (4 bytes)
- `resb count` = Reserve Bytes (allocate uninitialized space)
- `equ` = Define a constant
- `global` = Make symbol visible to linker
- `extern` = Declare external symbol

---

## The Multiboot Header Explained

```asm
MULTIBOOT_MAGIC     equ 0x1BADB002
MULTIBOOT_FLAGS     equ 0x00000003
MULTIBOOT_CHECKSUM  equ -(MULTIBOOT_MAGIC + MULTIBOOT_FLAGS)

dd MULTIBOOT_MAGIC
dd MULTIBOOT_FLAGS
dd MULTIBOOT_CHECKSUM
```

### Magic Number: 0x1BADB002
This is just a special number GRUB searches for. Why this number? 
- It's unlikely to appear by accident in a file
- It spells "BADBOOT" in hexspeak (programmer humor!)

### Flags: 0x00000003 (binary: 00000000000000000000000000000011)
Each bit enables a feature:
- Bit 0 (value 1): "Align loaded modules on page boundaries"
- Bit 1 (value 2): "Provide memory map information"
- Combined: 1 + 2 = 3 = 0x00000003

### Checksum: -(magic + flags)
Error detection mechanism. The formula ensures:
```
magic + flags + checksum = 0
```
If GRUB calculates this and doesn't get 0, the header is corrupted.

### Why `dd` (Define Double-word)?
- A "word" in x86 = 2 bytes (16 bits)
- A "double-word" = 4 bytes (32 bits)
- Each of these values is 32 bits, so we use `dd`

---

## The Stack Explained

### What is the Stack?
The stack is a region of memory used for:
- Storing local variables
- Saving return addresses when calling functions
- Passing function parameters (in some calling conventions)

### Key Properties:
1. **LIFO** - Last In, First Out (like a stack of plates)
2. **Grows DOWNWARD** - From high addresses to low addresses
3. **ESP points to the TOP** - The most recently added item

### Our Stack Setup:
```asm
stack_bottom:
    resb 16384      ; Reserve 16KB
stack_top:
```

**Visual representation:**
```
High Memory Address
    ‚Üë
    |  stack_top ‚Üê ESP points here initially
    |  [16KB of space for stack]
    ‚Üì
stack_bottom
Low Memory Address
```

When you call a function:
1. Parameters are pushed onto stack (ESP decreases)
2. Return address is pushed (ESP decreases more)
3. Local variables allocated (ESP decreases more)
4. When function returns, ESP moves back up

### Why 16KB?
- Just a reasonable size for initial boot
- Kernel doesn't do much complex work initially
- Can always allocate more memory later if needed

---

## Boot Code Walkthrough

### Step 1: Set Stack Pointer
```asm
mov esp, stack_top
```
**What this does:**
- Loads the address of `stack_top` into the ESP register
- Now the CPU knows where the stack is
- Any `push` or `call` instructions will use this stack

**Why necessary:**
- When GRUB starts your kernel, ESP is undefined
- You MUST set it before calling any functions
- Without a valid stack, `call` would corrupt random memory

### Step 2: Call Rust Kernel
```asm
call kernel_main
```
**What happens:**
1. CPU pushes return address onto stack (address of next instruction)
2. CPU jumps to `kernel_main` function
3. Rust code starts executing!

**The `extern` declaration:**
```asm
extern kernel_main
```
This tells the assembler: "kernel_main exists somewhere else (in our Rust code), trust me"

The linker will connect this call to your Rust function later.

### Step 3: Halt Forever
```asm
.hang:
    cli
    hlt
    jmp .hang
```

**Why this code:**
Your `kernel_main` is marked `-> !` (never returns), but if it somehow does:

- `cli` = Clear Interrupts (disable all interrupts)
- `hlt` = Halt CPU (enters low-power state until interrupt)
- Since we disabled interrupts, CPU sleeps forever
- `jmp .hang` = If an NMI (non-maskable interrupt) wakes CPU, jump back

**Local label `.hang`:**
The `.` prefix means it's a local label (scoped to _start)

---

## Memory Layout After Boot

When your kernel starts executing, memory looks like this:

```
0x00000000 - 0x000003FF : Real Mode IVT (Interrupt Vector Table)
0x00000400 - 0x000004FF : BIOS Data Area
0x00000500 - 0x00007BFF : Free memory (can use)
0x00007C00 - 0x00007DFF : Bootloader (GRUB was loaded here)
0x00007E00 - 0x0009FFFF : Free memory
0x000A0000 - 0x000FFFFF : Video memory, ROM, etc
0x00100000 - ...        : YOUR KERNEL LOADED HERE (1MB mark)
```

GRUB loads your kernel at 1MB to avoid the complicated memory regions below.

# What is a Linker Script?

**The Problem:**
You have multiple object files (.o):
- `boot.o` (from boot.asm) - has `.multiboot_header`, `.text`, `.bss` sections
- `libkfs.a` (from Rust) - has `.text`, `.rodata`, `.data` sections

How do you combine them into ONE bootable kernel binary? In what order? At what memory addresses?

**The Solution:**
A linker script tells the linker (ld) EXACTLY how to arrange all the pieces.

---

## Line-by-Line Breakdown

### Entry Point
```ld
ENTRY(_start)
```
**What it does:** Tells the linker "execution begins at _start"
- This is the `_start` label from boot.asm
- The linker marks this address as the entry point in the ELF header
- GRUB jumps to this address after loading the kernel

---

### The SECTIONS Command
```ld
SECTIONS
{
    ...
}
```
**What it does:** Defines how to organize output sections

Inside SECTIONS, we define:
- Where to place the kernel in memory
- What sections to include
- How to align them

---

### Setting the Base Address
```ld
. = 1M;
```
**The dot (.) is special:** It's called the "location counter"
- Represents the current memory address
- Setting it to 1M means "start placing things at 1MB (0x100000)"

**Why 1MB?**
- Below 1MB is messy (BIOS, VGA memory, etc.)
- GRUB loads your kernel at 1MB by default
- This is a standard convention

**Memory Map:**
```
0x000000 - 0x0FFFFF : Reserved/messy (below 1MB)
0x100000 (1M)       : YOUR KERNEL STARTS HERE
```

---

### Kernel Start Marker
```ld
_kernel_start = .;
```
**What it does:** Creates a symbol pointing to the kernel's start address

- `_kernel_start` will equal 0x100000 (1MB)
- You can reference this in your Rust/ASM code
- Useful for debugging or memory management later

---

### The Multiboot Section
```ld
.multiboot : ALIGN(4K)
{
    *(.multiboot_header)
}
```

**Breaking it down:**
- `.multiboot` - Name of the output section
- `ALIGN(4K)` - Align to 4096 bytes (page boundary)
- `*(.multiboot_header)` - Include ALL `.multiboot_header` sections from ALL input files

**Why first?**
- GRUB scans the first 8KB for the Multiboot header
- If we put it later, GRUB won't find it!
- This section MUST come before everything else

**The asterisk (*) means "all files":**
```
*(.multiboot_header)  ‚Üê "from ALL input files, take .multiboot_header sections"
```

---

### The Text Section (Code)
```ld
.text : ALIGN(4K)
{
    *(.text)
}
```

**What goes here:**
- All executable code (assembly and Rust)
- From boot.asm: the `_start` function
- From Rust: `kernel_main` and all other functions

**Why align to 4K?**
- 4KB = page size on x86
- Makes memory management easier later
- Standard practice for kernels

---

### The Read-Only Data Section
```ld
.rodata : ALIGN(4K)
{
    *(.rodata)
}
```

**What goes here:**
- String literals (like "42" or "Hello, World!")
- Constant data from Rust (`const` values)
- Anything marked read-only

**Why separate from .text?**
- Security: can mark as non-executable (prevents code injection attacks)
- Organization: keeps code and data separate

---

### The Data Section
```ld
.data : ALIGN(4K)
{
    *(.data)
}
```

**What goes here:**
- Initialized global/static variables
- Example: `static mut COUNTER: u32 = 0;`

**Initialized vs BSS:**
- `.data` = has initial values (stored in the binary)
- `.bss` = starts as zero (NOT stored, saves space)

---

### The BSS Section
```ld
.bss : ALIGN(4K)
{
    *(.bss)
}
```

**What goes here:**
- Uninitialized data (zero-initialized)
- From boot.asm: our stack (16KB)
- From Rust: `static mut VARIABLE: u32;` (no initial value)

**Why called BSS?**
- "Block Started by Symbol" (historical name)
- Doesn't take space in the binary file
- The bootloader zeros it out at runtime

**Example:**
```rust
static mut BIG_BUFFER: [u8; 1024] = [0; 1024];  // .data (wastes 1KB in binary)
static mut BIG_BUFFER: [u8; 1024];              // .bss (no space in binary!)
```

---

### Kernel End Marker
```ld
_kernel_end = .;
```

**What it does:** Marks where the kernel ends in memory

After all sections are placed, the location counter (.) points to the end.
We save this address as `_kernel_end`.

**Uses:**
- Calculate kernel size: `_kernel_end - _kernel_start`
- Know where free memory starts
- Memory allocator setup (in future projects)

---

## Memory Layout After Linking

After the linker runs, your kernel binary looks like this in memory:

```
0x00100000 (_kernel_start)
    ‚Üì
    [.multiboot]        ‚Üê Multiboot header (MUST be in first 8KB)
    [.text]             ‚Üê Code: _start, kernel_main, etc.
    [.rodata]           ‚Üê Constants, strings
    [.data]             ‚Üê Initialized globals
    [.bss]              ‚Üê Stack, uninitialized data
    ‚Üì
0x001XXXXX (_kernel_end)
```

Each section is aligned to 4KB boundaries.

---

## How Linking Works

**Step 1: Compile to object files**
```bash
nasm -f elf32 boot.asm -o boot.o
rustup run nightly cargo build -Z build-std=core --target i386-unknown-none.json
```

**Step 2: Link with linker script**
```bash
ld -n -T linker.ld -o kernel.bin boot.o target/.../libkfs.a
```

**What the linker does:**
1. Reads linker.ld to understand the layout
2. Collects all `.multiboot_header` sections ‚Üí places at 0x100000
3. Collects all `.text` sections ‚Üí places after multiboot
4. Collects all `.rodata` sections ‚Üí places after text
5. And so on...
6. Resolves symbols (connects `call kernel_main` to actual address)
7. Outputs final kernel.bin

---

## Common Linker Script Syntax

### The Location Counter (.)
```ld
. = 1M;           /* Set to 1MB */
. += 4K;          /* Add 4KB */
. = ALIGN(4K);    /* Round up to next 4KB boundary */
```

### Alignment
```ld
ALIGN(4K)         /* Align to 4KB */
ALIGN(0x1000)     /* Same thing (4KB in hex) */
```

### Section Matching
```ld
*(.text)          /* All .text sections from all files */
*(.text*)         /* .text, .text.startup, .text.xyz, etc */
boot.o(.text)     /* Only .text from boot.o */
```

### Creating Symbols
```ld
symbol_name = .;          /* Create a symbol at current location */
symbol_name = 0x1000;     /* Create a symbol with fixed address */
```

Now we can build and link our kernel:

```bash
rustup run nightly cargo build -Z build-std=core --target i386-unknown-none.json
ld -m elf_i386 -n -T linker.ld -o kernel.bin boot.o target/i386-unknown-none/debug/libkfs.a
```
---

# VGA Text Mode Guide

## What is VGA Text Mode?

VGA (Video Graphics Array) text mode is a simple way to display text on screen without complex graphics drivers. When your computer boots, it starts in VGA text mode by default.

**Key Features:**
- **80 columns √ó 25 rows** = 2000 characters on screen
- **16 colors** for foreground and background
- **Memory-mapped** at address 0xB8000
- No graphics card driver needed!

---

## Memory Layout

### VGA Buffer Location
The VGA text buffer is at physical memory address **0xB8000**.

**Each character takes 2 bytes:**
```
[Byte 0]: ASCII character code
[Byte 1]: Color attribute (4 bits background, 4 bits foreground)
```

**Example: Writing 'A' in white on black**
```
Address 0xB8000: 0x41  (ASCII 'A')
Address 0xB8001: 0x0F  (black background, white foreground)
```

### Buffer Layout
```
Screen Position (0,0)  ‚Üí Address 0xB8000
Screen Position (0,1)  ‚Üí Address 0xB8002
Screen Position (0,2)  ‚Üí Address 0xB8004
...
Screen Position (1,0)  ‚Üí Address 0xB80A0  (80 * 2 = 160 bytes per row)
```

**Formula for position (row, col):**
```
offset = (row * 80 + col) * 2
character_address = 0xB8000 + offset
color_address = 0xB8000 + offset + 1
```

---

## Color Codes

### Color Byte Format
```
Bit:  7 6 5 4 | 3 2 1 0
      ---------+---------
      Background|Foreground
```

### Color Values
| Value | Color       | Value | Color       |
|-------|-------------|-------|-------------|
| 0     | Black       | 8     | Dark Gray   |
| 1     | Blue        | 9     | Light Blue  |
| 2     | Green       | 10    | Light Green |
| 3     | Cyan        | 11    | Light Cyan  |
| 4     | Red         | 12    | Light Red   |
| 5     | Magenta     | 13    | Pink        |
| 6     | Brown       | 14    | Yellow      |
| 7     | Light Gray  | 15    | White       |

**Example Color Bytes:**
```rust
// White text on black background
let color = (0 << 4) | 15;  // 0x0F

// Green text on blue background  
let color = (1 << 4) | 2;   // 0x12

// Yellow text on red background
let color = (4 << 4) | 14;  // 0x4E
```

---

## Code Walkthrough

### 1. Writing a Character

```rust
const VGA_BUFFER: *mut u8 = 0xb8000 as *mut u8;

fn write_char(row: usize, col: usize, c: u8, color: u8) {
    let offset = (row * 80 + col) * 2;
    unsafe {
        *VGA_BUFFER.add(offset) = c;           // Write character
        *VGA_BUFFER.add(offset + 1) = color;   // Write color
    }
}
```

**What happens:**
1. Calculate memory offset for position
2. Write character byte at offset
3. Write color byte at offset + 1

**Why unsafe?**
- Raw pointer dereferencing is unsafe in Rust
- Writing to arbitrary memory address could corrupt system
- We know 0xB8000 is safe (VGA buffer), so we use `unsafe`

### 2. Writing a String

```rust
pub fn write_string(&mut self, s: &str) {
    for byte in s.bytes() {
        match byte {
            // Only allow printable ASCII
            0x20..=0x7e | b'\n' => self.write_byte(byte),
            // Replace non-ASCII with box character
            _ => self.write_byte(0xfe),
        }
    }
}
```

**What happens:**
1. Iterate through each byte in the string
2. If printable ASCII (space to ~) or newline ‚Üí write it
3. If not printable ‚Üí write box character (ÔøΩ)

**Why check ASCII range?**
- VGA text mode only supports ASCII
- Extended Unicode characters won't display correctly
- Filtering prevents garbage on screen

### 3. Color Encoding

```rust
pub fn color_byte(fg: Color, bg: Color) -> u8 {
    (bg as u8) << 4 | (fg as u8)
}
```

**Breakdown:**
- `bg as u8` - Convert background color to u8 (0-15)
- `<< 4` - Shift left 4 bits (move to upper 4 bits)
- `fg as u8` - Foreground color (0-15)
- `|` - Bitwise OR to combine them

**Example:**
```
fg = Green (2)       = 0000 0010
bg = Blue (1)        = 0000 0001
bg << 4              = 0001 0000
(bg << 4) | fg       = 0001 0010 = 0x12
```

### 4. Clearing the Screen

```rust
pub fn clear_screen(&mut self) {
    for row in 0..VGA_HEIGHT {
        for col in 0..VGA_WIDTH {
            let offset = (row * VGA_WIDTH + col) * 2;
            unsafe {
                *VGA_BUFFER.add(offset) = b' ';        // Space character
                *VGA_BUFFER.add(offset + 1) = self.color;
            }
        }
    }
    self.column = 0;
    self.row = 0;
}
```

**What happens:**
1. Loop through all 2000 positions (25 rows √ó 80 cols)
2. Write space character (0x20) at each position
3. Write current color attribute
4. Reset cursor to top-left (0, 0)

---

## Using the VGA Writer

### Basic Usage

```rust
// Create writer
let mut writer = vga::Writer::new();

// Clear screen
writer.clear_screen();

// Change color
writer.set_color(vga::Color::Yellow, vga::Color::Blue);

// Write text
writer.write_string("Hello, World!");
```

### Advanced: Using write! Macro

Since we implemented `fmt::Write`, you can use Rust's `write!` macro:

```rust
use core::fmt::Write;

let mut writer = vga::Writer::new();
write!(writer, "Number: {}", 42).unwrap();
```

---

## Memory Safety

### Why Raw Pointers?

```rust
const VGA_BUFFER: *mut u8 = 0xb8000 as *mut u8;
```

**Can't use safe Rust because:**
1. VGA buffer is at a fixed hardware address
2. Not allocated by Rust's allocator
3. Accessed directly via memory-mapped I/O

**Safety guarantees we provide:**
1. VGA buffer IS at 0xB8000 (hardware spec)
2. We never write beyond buffer bounds
3. We only write valid ASCII characters
4. All unsafe blocks are clearly marked

### Bounds Checking

```rust
if self.column >= VGA_WIDTH {
    self.new_line();
}

if self.row >= VGA_HEIGHT {
    self.row = VGA_HEIGHT - 1;
}
```

We prevent writing outside the buffer by:
- Wrapping to new line when column exceeds 80
- Stopping at bottom row when exceeding 25 rows
- Could implement scrolling instead

---

## Testing Your VGA Code

### Displaying "42"

```rust
#[no_mangle]
pub extern "C" fn kernel_main() -> ! {
    let mut writer = vga::Writer::new();
    writer.clear_screen();
    writer.write_string("42");
    loop {}
}
```

**When you boot:**
1. Screen clears (all black)
2. "42" appears in top-left corner
3. In white text (default color)
4. Kernel halts (infinite loop)

### Adding More Text

```rust
writer.write_string("42\n");          // "42" then newline
writer.write_string("Hello, Kernel!"); // On next line
```

### Colorful Output

```rust
writer.set_color(vga::Color::LightGreen, vga::Color::Black);
writer.write_string("42");
```

Now we can build and link our kernel:

```bash
rustup run nightly cargo build -Z build-std=core --target i386-unknown-none.json
ld -m elf_i386 -n -T linker.ld -o kernel.bin boot.o target/i386-unknown-none/debug/libkfs.a
```

---

# Boot it up

Test your kernel directly:

```bash
qemu-system-i386 -kernel kernel.bin
```

This should open a QEMU window and you'll see "42" displayed on a black screen!

![firstprint](/imgs/firstprint.png "First Print")

## Common Issues

### Issue 1: Nothing appears on screen
**Cause:** Wrong memory address
**Fix:** Verify VGA_BUFFER is 0xB8000

### Issue 2: Garbage characters
**Cause:** Writing non-ASCII characters
**Fix:** Filter bytes in write_string (already done)

### Issue 3: Text in wrong position
**Cause:** Incorrect offset calculation
**Fix:** Verify formula: `(row * 80 + col) * 2`

### Issue 4: Colors wrong
**Cause:** Background/foreground swapped
**Fix:** Background is upper 4 bits, foreground is lower 4 bits

# Going all the Way

##Print Macros Guide - println! and printk!

## What We Added

You now have three macros for easy printing:

1. **`print!(...)`** - Print without newline
2. **`println!(...)`** - Print with newline
3. **`printk!(...)`** - Kernel print (alias for `print!`)

## Usage Examples

### Basic Printing

```rust
print!("Hello");           // No newline
println!("World");         // With newline
println!();                // Just newline
```

**Output:**
```
HelloWorld
```

### Formatted Output

```rust
let x = 42;
let name = "Alice";

println!("Number: {}", x);
println!("Name: {}", name);
println!("Both: {} and {}", x, name);
```

**Output:**
```
Number: 42
Name: Alice
Both: 42 and Alice
```

### Debug Printing

```rust
printk!("[DEBUG] Kernel initialized\n");
printk!("[INFO] Value: {}\n", 100);
```

**Output:**
```
[DEBUG] Kernel initialized
[INFO] Value: 100
```

---

## How It Works

### 1. The Global Writer

```rust
static mut WRITER: Writer = Writer::new();
```

**What this does:**
- Creates a single, global VGA writer
- Lives for the entire program lifetime
- Shared across all print calls

**Why `static mut`?**
- `static` = lives forever
- `mut` = we need to modify it (write to screen)
- Unsafe because multiple parts of code could access it

### 2. The Print Function

```rust
pub fn _print(args: fmt::Arguments) {
    use core::fmt::Write;
    unsafe {
        WRITER.write_fmt(args).unwrap();
    }
}
```

**What this does:**
- Takes formatted arguments from the macro
- Writes them to the global WRITER
- Uses `fmt::Write` trait we implemented

**Why the leading underscore?**
- Convention for "private" helper function
- Users call the macro, not this function directly

### 3. The Macros

#### print! macro
```rust
#[macro_export]
macro_rules! print {
    ($($arg:tt)*) => ($crate::vga::_print(format_args!($($arg)*)));
}
```

**Breakdown:**
- `macro_rules!` = define a macro
- `$($arg:tt)*` = accept any number of "token trees" (anything!)
- `format_args!` = Rust's built-in formatting
- `$crate::vga::_print` = call our print function

**What happens:**
```rust
print!("Value: {}", 42)
  ‚Üì
format_args!("Value: {}", 42)  // Creates fmt::Arguments
  ‚Üì
_print(args)                    // Calls our function
  ‚Üì
WRITER.write_fmt(args)          // Writes to VGA buffer
```

#### println! macro
```rust
#[macro_export]
macro_rules! println {
    () => ($crate::print!("\n"));
    ($($arg:tt)*) => ($crate::print!("{}\n", format_args!($($arg)*)));
}
```

**Two patterns:**
1. `println!()` ‚Üí just prints newline
2. `println!("...")` ‚Üí prints text then newline

**Example:**
```rust
println!("Hello")
  ‚Üì
print!("{}\n", format_args!("Hello"))
  ‚Üì
_print(args)  // args contains "Hello\n"
```

#### printk! macro
```rust
#[macro_export]
macro_rules! printk {
    ($($arg:tt)*) => ($crate::print!($($arg)*));
}
```

**Just an alias:**
- Calls `print!` internally
- Exists because "printk" is the traditional Linux kernel print function
- Makes kernel code look more authentic!

---

## Advanced Features

### Formatting Options

Rust's `format_args!` supports many formats:

```rust
println!("{}", 42);        // Decimal: 42
println!("{:x}", 42);      // Hex: 2a
println!("{:b}", 42);      // Binary: 101010
println!("{:?}", value);   // Debug format (need Debug trait)
```

**In our kernel, only basic formats work** because we're in `no_std`:
- `{}` - Display trait ‚úì
- `{:x}` - Hex ‚úì
- `{:b}` - Binary ‚úì
- `{:?}` - Debug ‚úó (requires std)

### Accessing the Writer Directly

Sometimes you need direct access:

```rust
// Change color
vga::writer().set_color(vga::Color::Red, vga::Color::Black);

// Then print with new color
println!("This is red!");

// Clear screen
vga::writer().clear_screen();
```

---

## Safety Considerations

### Global Mutable State

```rust
static mut WRITER: Writer = Writer::new();
```

**Potential issues:**
- Multiple functions could access WRITER simultaneously
- Could cause race conditions (in multi-threaded code)

**Why it's safe NOW:**
- Kernel is single-threaded (no interrupts yet)
- Only one function runs at a time
- No concurrent access possible

**When we add interrupts:**
- Will need a spinlock around WRITER
- Prevents interrupt handlers from corrupting output

### The `unsafe` Block

```rust
unsafe {
    WRITER.write_fmt(args).unwrap();
}
```

**Why unsafe?**
- Accessing `static mut` is always unsafe in Rust
- Compiler can't guarantee no concurrent access
- We manually guarantee safety

**Could we avoid unsafe?**
- Yes, with a mutex/spinlock wrapper
- But adds complexity for single-threaded code
- We'll add it when we implement interrupts

---

## Macro Export

```rust
#[macro_export]
macro_rules! print { ... }
```

**What `#[macro_export]` does:**
- Makes macro available to other modules
- Puts it in crate root (not vga module)
- Allows `print!()` instead of `vga::print!()`

**Why at crate root?**
- Matches Rust convention (std's `println!`)
- Cleaner syntax
- Easier to use

---

## Comparison to Standard Rust

### Standard Rust (with std)
```rust
println!("Hello");  // Goes to stdout
```

### Our Kernel
```rust
println!("Hello");  // Goes to VGA buffer at 0xB8000
```

**Same syntax, different destination!**

---

## Testing the Macros

Update your `kernel_main`:

```rust
#[no_mangle]
pub extern "C" fn kernel_main() -> ! {
    vga::writer().clear_screen();
    
    // Test 1: Basic
    println!("42");
    
    // Test 2: Formatting
    println!("The answer is {}", 42);
    
    // Test 3: Multiple values
    let x = 13;
    let y = 37;
    println!("x={}, y={}", x, y);
    
    // Test 4: Hex
    println!("Hex: {:x}", 255);  // Prints "ff"
    
    loop {}
}
```

**Build and run:**
```bash
make run
```

**You should see:**
```
42
The answer is 42
x=13, y=37
Hex: ff
```

---

## Common Errors

### Error: "format argument must be a string literal"
```rust
let format = "Value: {}";
println!(format, 42);  // ERROR!
```

**Fix:** Format string must be a literal:
```rust
println!("Value: {}", 42);  // OK
```

### Error: "cannot find macro `println` in this scope"
**Fix:** Add `#[macro_use]` to vga module:
```rust
#[macro_use]
mod vga;
```

### No output appears
**Fix:** Make sure you're not hitting the screen edge (row 25)

---

## Next Steps

Now that you have print macros:

1. **Test thoroughly** - Try different formats
2. **Update panic handler** - Print panic messages!
3. **Add scroll support** - So output doesn't disappear
4. **Use for debugging** - Print values while coding

**Ready for the next bonus feature?**
- Scroll support (when screen fills)
- Cursor support (show where text appears)
- Both work great with print macros!

---

## Example: Better Panic Handler

Now we can improve the panic handler:

```rust
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    vga::writer().set_color(vga::Color::White, vga::Color::Red);
    println!("\n!!! KERNEL PANIC !!!");
    println!("{}", info);
    loop {}
}
```

## Cursor and Scroll Support Guide

## New Features Added

1. **Automatic Scrolling** - Screen scrolls up when you reach the bottom
2. **Hardware Cursor** - Blinking cursor shows where text appears
3. **Cursor Positioning** - Move cursor anywhere on screen
4. **Show/Hide Cursor** - Control cursor visibility

---

## Feature 1: Automatic Scrolling

### What It Does

When you print past the bottom of the screen (row 24), instead of stopping, the screen automatically scrolls up to make room.

### How It Works

```rust
fn scroll(&mut self) {
    unsafe {
        // Move each line up by one
        for row in 1..VGA_HEIGHT {
            for col in 0..VGA_WIDTH {
                let src_offset = (row * VGA_WIDTH + col) * 2;
                let dst_offset = ((row - 1) * VGA_WIDTH + col) * 2;
                
                // Copy character and color
                *VGA_BUFFER.add(dst_offset) = *VGA_BUFFER.add(src_offset);
                *VGA_BUFFER.add(dst_offset + 1) = *VGA_BUFFER.add(src_offset + 1);
            }
        }
        
        // Clear the last line
        for col in 0..VGA_WIDTH {
            let offset = ((VGA_HEIGHT - 1) * VGA_WIDTH + col) * 2;
            *VGA_BUFFER.add(offset) = b' ';
            *VGA_BUFFER.add(offset + 1) = self.color;
        }
    }
    
    self.row = VGA_HEIGHT - 1;
    self.column = 0;
}
```

**Step by step:**

1. **Loop through rows 1-24** (skip row 0, it will be deleted)
2. **Copy each row up one position**
   - Row 1 ‚Üí Row 0
   - Row 2 ‚Üí Row 1
   - Row 24 ‚Üí Row 23
3. **Clear the bottom row** (row 24) with spaces
4. **Keep cursor on bottom row**

**Visual example:**
```
Before scroll:           After scroll:
Row 0: Line 1           Row 0: Line 2
Row 1: Line 2           Row 1: Line 3
Row 2: Line 3           Row 2: Line 4
Row 3: Line 4           Row 3: [empty]
```

### When It Triggers

```rust
fn new_line(&mut self) {
    self.column = 0;
    
    if self.row < VGA_HEIGHT - 1 {
        self.row += 1;  // Normal case: move down
    } else {
        self.scroll();  // At bottom: scroll up!
    }
}
```

Scrolling happens when:
- You're on the last row (24)
- You print a newline (`\n`)
- Text wraps to next line

---

## Feature 2: Hardware Cursor

### What It Does

The blinking cursor you see on screen is controlled by the VGA hardware. We can:
- Move it anywhere
- Show or hide it
- Make it follow text as you type

### VGA Cursor Registers

The VGA card has hardware registers to control the cursor:

**Port 0x3D4** - Control register (which setting to change)
**Port 0x3D5** - Data register (the value to set)

**Cursor position registers:**
- **0x0E** - Cursor Location High (upper 8 bits of position)
- **0x0F** - Cursor Location Low (lower 8 bits of position)

**Cursor appearance registers:**
- **0x0A** - Cursor Start (top scanline)
- **0x0B** - Cursor End (bottom scanline)

### Port I/O

To communicate with VGA hardware, we use **I/O ports**:

```rust
#[inline]
unsafe fn outb(port: u16, value: u8) {
    core::arch::asm!(
        "out dx, al",
        in("dx") port,
        in("al") value,
        options(nomem, nostack, preserves_flags)
    );
}
```

**What this does:**
- Uses x86 `out` instruction
- Sends a byte (`al`) to a port (`dx`)
- Inline assembly in Rust

**Breaking down the assembly:**
```
out dx, al
```
- `out` - Output to I/O port
- `dx` - Port number (16-bit register)
- `al` - Value to send (8-bit register)

---

## Feature 3: Update Cursor Position

### The Code

```rust
fn update_cursor(&self) {
    let pos = self.row * VGA_WIDTH + self.column;
    
    unsafe {
        // Send high byte
        outb(VGA_CTRL_PORT, 0x0E);
        outb(VGA_DATA_PORT, (pos >> 8) as u8);
        
        // Send low byte
        outb(VGA_CTRL_PORT, 0x0F);
        outb(VGA_DATA_PORT, pos as u8);
    }
}
```

**Step by step:**

1. **Calculate position** - Convert (row, col) to linear position
   - Example: row 5, col 10 = 5 * 80 + 10 = 410

2. **Send high byte**
   ```rust
   outb(VGA_CTRL_PORT, 0x0E);  // Select "cursor high" register
   outb(VGA_DATA_PORT, (pos >> 8) as u8);  // Send upper 8 bits
   ```

3. **Send low byte**
   ```rust
   outb(VGA_CTRL_PORT, 0x0F);  // Select "cursor low" register
   outb(VGA_DATA_PORT, pos as u8);  // Send lower 8 bits
   ```

**Why split into high/low bytes?**
- Position is 16 bits (0-1999 for 80x25 screen)
- Ports are 8 bits wide
- Must send in two parts

**Example:**
```
Position 410 = 0x019A
High byte = 0x01
Low byte = 0x9A
```

---

## Feature 4: Show/Hide Cursor

```rust
pub fn set_cursor_visible(&self, visible: bool) {
    unsafe {
        outb(VGA_CTRL_PORT, 0x0A);
        let cursor_start = if visible { 0x0E } else { 0x20 };
        outb(VGA_DATA_PORT, cursor_start);
    }
}
```

**How it works:**

Register 0x0A controls cursor appearance:
- Bits 0-4: Cursor start scanline (0-15)
- Bit 5: **Cursor disable bit**

**Values:**
- `0x0E` (14) - Visible cursor starting at scanline 14
- `0x20` (32) - Bit 5 set = cursor disabled

**Why 0x0E?**
- Characters are 16 scanlines tall (0-15)
- Starting at 14 makes a small cursor at bottom
- Classic blinking underscore look

---

## Feature 5: Manual Cursor Positioning

```rust
pub fn set_cursor_position(&mut self, row: usize, col: usize) {
    if row < VGA_HEIGHT && col < VGA_WIDTH {
        self.row = row;
        self.column = col;
        self.update_cursor();
    }
}

pub fn get_cursor_position(&self) -> (usize, usize) {
    (self.row, self.column)
}
```

**Usage:**

```rust
// Jump to middle of screen
vga::writer().set_cursor_position(12, 40);
println!("Center text!");

// Get current position
let (row, col) = vga::writer().get_cursor_position();
println!("At row {}, col {}", row, col);
```

**Use cases:**
- Status bars (always top/bottom row)
- Menus (fixed positions)
- Games (character movement)
- Text editors (cursor movement)

---

## How Everything Works Together

### When You Print Text

```rust
pub fn write_byte(&mut self, byte: u8) {
    match byte {
        b'\n' => self.new_line(),
        byte => {
            // ... write character ...
            self.column += 1;
        }
    }
    self.update_cursor();  // ‚Üê Cursor follows text!
}
```

**Flow:**
1. Write character to VGA buffer
2. Increment column
3. Update hardware cursor position
4. Cursor appears right after character

### When You Hit Bottom of Screen

```
println!("Line 1");
println!("Line 2");
...
println!("Line 25");  ‚Üê Triggers scroll!
println!("Line 26");  ‚Üê Appears on bottom row
```

**What happens:**
1. Line 25 prints normally
2. `println!` tries to add newline
3. We're at row 24 (last row)
4. `new_line()` calls `scroll()`
5. Screen scrolls up
6. Line 26 appears on bottom
7. Cursor updates to track position

---

## VGA Hardware Details

### Memory Layout

```
VGA Text Buffer: 0xB8000
Size: 80 cols √ó 25 rows √ó 2 bytes = 4000 bytes

Each character = 2 bytes:
[0]: ASCII character
[1]: Attribute (color)
```

### I/O Ports

```
0x3D4: VGA Index Register
0x3D5: VGA Data Register

Common registers:
0x0A: Cursor Start
0x0B: Cursor End
0x0E: Cursor Location High
0x0F: Cursor Location Low
```

### Why Port I/O?

**Memory-mapped I/O** - VGA buffer at 0xB8000
- Good for: Reading/writing display data
- Direct memory access

**Port I/O** - VGA control at ports 0x3D4/0x3D5
- Good for: Hardware configuration
- Separate from memory space
- Uses special CPU instructions (`in`, `out`)

---

## Safety Considerations

### Inline Assembly

```rust
core::arch::asm!(
    "out dx, al",
    in("dx") port,
    in("al") value,
    options(nomem, nostack, preserves_flags)
);
```

**Why unsafe?**
- Direct hardware access
- Could crash system if wrong port/value
- Bypasses Rust's safety

**Why it's safe here:**
- VGA ports are well-documented
- Values are validated
- Common, stable hardware interface

### Scrolling Memory Copies

```rust
*VGA_BUFFER.add(dst_offset) = *VGA_BUFFER.add(src_offset);
```

**Potential issues:**
- Raw pointer arithmetic
- Could write outside buffer
- Could corrupt display

**Why it's safe:**
- We validate row/col bounds
- Offsets always within 0-3999
- VGA buffer is dedicated memory

---

## Testing Your Implementation

### Test 1: Basic Scrolling

```rust
for i in 1..=30 {
    println!("Line {}", i);
}
```

**Expected:**
- First 25 lines appear normally
- Lines 26-30 cause scrolling
- You can see lines 6-30 at the end

### Test 2: Cursor Positioning

```rust
vga::writer().clear_screen();
vga::writer().set_cursor_position(10, 40);
print!("Middle!");
```

**Expected:**
- Text appears in center of screen
- Cursor blinks after "Middle!"

### Test 3: Cursor Visibility

```rust
vga::writer().set_cursor_visible(false);
println!("No cursor");
vga::writer().set_cursor_visible(true);
println!("Cursor back!");
```

**Expected:**
- First line has no blinking cursor
- Second line has cursor again

---

## Common Issues

### Issue: Cursor doesn't move
**Cause:** Forgot to call `update_cursor()`
**Fix:** Call after every `write_byte()`

### Issue: Scroll is slow
**Cause:** Copying 4000 bytes is expensive
**Fix:** Normal for software scrolling; hardware scroll requires VGA registers

### Issue: Cursor in wrong position
**Cause:** Position calculation wrong
**Fix:** Verify: `pos = row * 80 + col`

### Issue: Assembly doesn't compile
**Cause:** Missing `core::arch::asm!` feature
**Fix:** Should work on nightly, we're already using it

---

## Performance Notes

### Scrolling Speed

Copying 2000 characters (4000 bytes):
- ~4000 memory writes
- Not instant, but fast enough
- Could optimize with rep movsb instruction

### Cursor Updates

Each `write_byte()` calls `update_cursor()`:
- 4 port I/O operations
- Relatively slow (but acceptable)
- Could batch updates (update once per string)

**Optimization idea:**
```rust
pub fn write_string(&mut self, s: &str) {
    for byte in s.bytes() {
        // ... write bytes ...
    }
    self.update_cursor();  // Once at end instead of per byte
}
```

## Feature 6: Keyboard Input Guide - Interrupts and Hardware I/O

## Overview

Keyboard input is the most complex feature because it requires:
1. **Interrupts** - Hardware signals that stop CPU execution
2. **IDT** - Interrupt Descriptor Table (tells CPU where handlers are)
3. **PIC** - Programmable Interrupt Controller (manages interrupts)
4. **Scan codes** - Raw keyboard codes that need translation
5. **ASCII conversion** - Convert scan codes to printable characters

This guide explains everything from scratch.

---

## What Are Interrupts?

### The Problem

Your kernel runs in a loop:
```rust
loop {
    // Do stuff
}
```

How does the keyboard tell the kernel "hey, a key was pressed"?

**Bad solution:** Polling
```rust
loop {
    if keyboard_has_data() {
        read_keyboard();
    }
}
```
- Wastes CPU cycles
- Checks constantly even when nothing happens
- Inefficient

**Good solution:** Interrupts
```rust
loop {
    hlt(); // Sleep until interrupt
}

// Somewhere else...
fn keyboard_interrupt_handler() {
    read_keyboard(); // Only runs when key pressed!
}
```
- CPU sleeps until key pressed
- Hardware wakes CPU automatically
- Efficient!

### How Interrupts Work

1. **Key is pressed** ‚Üí Keyboard hardware sends electrical signal
2. **PIC receives signal** ‚Üí Routes it to CPU as IRQ1
3. **CPU stops** ‚Üí Saves current state
4. **CPU looks up handler** ‚Üí Checks IDT for IRQ1 handler
5. **Handler runs** ‚Üí Your `keyboard_interrupt_handler()` executes
6. **CPU resumes** ‚Üí Returns to what it was doing

---

## Interrupt Descriptor Table (IDT)

### What Is It?

The IDT is a table that tells the CPU:
- "When interrupt X happens, call function Y"

**Structure:**
```
IDT Entry 0  ‚Üí Divide by zero handler
IDT Entry 1  ‚Üí Debug handler
...
IDT Entry 32 ‚Üí Timer interrupt (IRQ0)
IDT Entry 33 ‚Üí Keyboard interrupt (IRQ1)  ‚Üê We care about this!
...
IDT Entry 255 ‚Üí Last entry
```

### IDT Entry Structure

```rust
#[repr(C, packed)]
struct IdtEntry {
    offset_low: u16,    // Lower 16 bits of handler address
    selector: u16,      // Code segment selector (0x08 = kernel code)
    zero: u8,           // Always 0
    type_attr: u8,      // 0x8E = present, DPL=0, 32-bit interrupt gate
    offset_high: u16,   // Upper 16 bits of handler address
}
```

**Breaking it down:**

**offset_low + offset_high:**
- Combined form the 32-bit address of your handler function
- Example: Handler at 0x00102030
  - offset_low = 0x2030
  - offset_high = 0x0010

**selector:**
- Code segment where handler lives
- 0x08 = kernel code segment (set by bootloader/GRUB)

**type_attr:**
- Bit 7: Present (1 = entry is valid)
- Bits 6-5: DPL (0 = kernel privilege)
- Bits 4-0: Type (0xE = 32-bit interrupt gate)
- Combined: 0x8E

### Setting an IDT Entry

```rust
fn set_handler(&mut self, handler: unsafe extern "C" fn()) {
    let handler_addr = handler as usize;
    self.offset_low = (handler_addr & 0xFFFF) as u16;
    self.offset_high = ((handler_addr >> 16) & 0xFFFF) as u16;
    self.selector = 0x08;
    self.zero = 0;
    self.type_attr = 0x8E;
}
```

**Example:**
```
Handler function at: 0x00102ABC

offset_low  = 0x2ABC (lower 16 bits)
offset_high = 0x0010 (upper 16 bits)
```

### Loading the IDT

```rust
#[repr(C, packed)]
struct IdtPointer {
    limit: u16,  // Size of IDT - 1
    base: u32,   // Address of IDT
}

// Load with lidt instruction
asm!(
    "lidt [{}]",
    in(reg) &idt_ptr,
);
```

**What this does:**
- Tells CPU "the IDT is at this address"
- CPU will use it for all future interrupts

---

## Programmable Interrupt Controller (PIC)

### What Is It?

The PIC (8259 chip) manages hardware interrupts:
- Receives signals from keyboard, mouse, timer, etc.
- Prioritizes them
- Sends them to CPU one at a time

**Two PICs:**
- **PIC1** (Master) - Handles IRQ0-7
- **PIC2** (Slave) - Handles IRQ8-15, connected to PIC1's IRQ2

### IRQ Mapping

**Before remapping:**
```
IRQ0 (Timer)    ‚Üí Interrupt 8   ‚Üê CONFLICT! (CPU exception)
IRQ1 (Keyboard) ‚Üí Interrupt 9   ‚Üê CONFLICT!
...
```

**After remapping:**
```
IRQ0 (Timer)    ‚Üí Interrupt 32
IRQ1 (Keyboard) ‚Üí Interrupt 33  ‚Üê No conflict!
IRQ2 (Cascade)  ‚Üí Interrupt 34
...
```

### Why Remap?

**The problem:**
- CPU reserves interrupts 0-31 for exceptions (divide by zero, page fault, etc.)
- Old PIC mapping uses interrupts 8-15
- **Conflict!** Keyboard interrupt overwrites "double fault" exception

**The solution:**
- Remap PIC to use interrupts 32-47
- No more conflicts!

### PIC Remapping Code

```rust
pub fn remap() {
    unsafe {
        // Start initialization
        outb(PIC1_COMMAND, ICW1_INIT);
        outb(PIC2_COMMAND, ICW1_INIT);

        // Set vector offsets
        outb(PIC1_DATA, 32);  // IRQ0-7 ‚Üí interrupts 32-39
        outb(PIC2_DATA, 40);  // IRQ8-15 ‚Üí interrupts 40-47

        // Tell PICs about each other
        outb(PIC1_DATA, 4);   // PIC2 at IRQ2
        outb(PIC2_DATA, 2);   // Cascade identity

        // Set 8086 mode
        outb(PIC1_DATA, ICW4_8086);
        outb(PIC2_DATA, ICW4_8086);

        // Enable keyboard (IRQ1), disable others
        outb(PIC1_DATA, 0xFD); // 0xFD = 11111101 (IRQ1 enabled)
        outb(PIC2_DATA, 0xFF); // All disabled
    }
}
```

### End of Interrupt (EOI)

After handling an interrupt, you MUST tell the PIC "I'm done":

```rust
pub fn send_eoi(irq: u8) {
    unsafe {
        if irq >= 8 {
            outb(PIC2_COMMAND, PIC_EOI);  // Tell slave PIC
        }
        outb(PIC1_COMMAND, PIC_EOI);      // Tell master PIC
    }
}
```

**Why?**
- PIC won't send more interrupts until you acknowledge
- Keyboard won't work if you forget this!

---

## Keyboard Hardware

### PS/2 Keyboard

**Data Port:** 0x60
- Read scan codes from here

**Status Port:** 0x64
- Check if data is available (we don't use this, just read directly)

### Scan Codes

When you press a key, the keyboard sends a **scan code**:

**Key press:** Scan code < 128
```
Press 'A' ‚Üí Scan code 0x1E (30 in decimal)
```

**Key release:** Scan code + 128
```
Release 'A' ‚Üí Scan code 0x9E (158 in decimal)
```

### Scan Code to ASCII

```rust
static SCANCODE_TO_ASCII: [u8; 128] = [
    0,    // 0x00
    27,   // 0x01 - Escape
    b'1', // 0x02
    b'2', // 0x03
    // ...
    b' ', // 0x39 - Space
    // ...
];
```

**Example:**
```
Scan code 0x1E ‚Üí SCANCODE_TO_ASCII[0x1E] = b'a'
```

---

## Keyboard Interrupt Handler

### The Handler Function

```rust
#[no_mangle]
pub extern "C" fn keyboard_interrupt_handler() {
    unsafe {
        // 1. Read scan code from keyboard
        let scancode = inb(KEYBOARD_DATA_PORT);

        // 2. Check if it's a key press (not release)
        if scancode < 128 {
            // 3. Convert to ASCII
            let ascii = SCANCODE_TO_ASCII[scancode as usize];
            
            // 4. Print character
            if ascii != 0 {
                print!("{}", ascii as char);
            }
        }

        // 5. IMPORTANT: Tell PIC we're done
        pic::send_eoi(1);
    }
}
```

**Step by step:**

1. **Read scan code** - Get byte from port 0x60
2. **Filter releases** - Ignore key releases (scancode >= 128)
3. **Convert to ASCII** - Look up in table
4. **Print** - Display character
5. **Send EOI** - Tell PIC we're done (CRITICAL!)

### Why `#[no_mangle]`?

```rust
#[no_mangle]
pub extern "C" fn keyboard_interrupt_handler()
```

- `#[no_mangle]` - Keep function name as-is (don't scramble it)
- `extern "C"` - Use C calling convention (required for interrupts)
- Without these, the linker can't find your handler!

---

## Putting It All Together

### Initialization Sequence

```rust
fn kernel_main() -> ! {
    // 1. Initialize IDT
    idt::init();           // Set up interrupt table
    
    // 2. Configure PIC
    pic::remap();          // Remap IRQs to 32-47
    
    // 3. Enable interrupts
    idt::enable_interrupts(); // Run 'sti' instruction
    
    // 4. Wait for interrupts
    loop {
        hlt();  // Sleep until interrupt
    }
}
```

### What Happens When You Press a Key

```
[1] You press 'A'
    ‚Üì
[2] Keyboard sends scan code 0x1E to port 0x60
    ‚Üì
[3] Keyboard sends electrical signal to PIC
    ‚Üì
[4] PIC sends IRQ1 to CPU
    ‚Üì
[5] CPU checks IDT entry 33 (IRQ1 after remapping)
    ‚Üì
[6] CPU finds keyboard_interrupt_handler address
    ‚Üì
[7] CPU saves state and jumps to handler
    ‚Üì
[8] Handler:
    - Reads 0x1E from port 0x60
    - Looks up: SCANCODE_TO_ASCII[0x1E] = b'a'
    - Prints 'a' to screen
    - Sends EOI to PIC
    ‚Üì
[9] CPU restores state and returns to loop
    ‚Üì
[10] Loop continues (hlt until next key)
```

---

## Port I/O

### What Is Port I/O?

**Memory-mapped I/O:** (VGA buffer at 0xB8000)
```rust
*VGA_BUFFER.add(offset) = byte;  // Normal memory write
```

**Port I/O:** (Keyboard at port 0x60)
```rust
outb(0x60, value);  // Special CPU instruction
value = inb(0x60);  // Special CPU instruction
```

**Why different?**
- Hardware has limited address space
- Port I/O uses separate address space (0-65535)
- Requires special CPU instructions (`in`, `out`)

### Inline Assembly for Port I/O

**Output byte:**
```rust
unsafe fn outb(port: u16, value: u8) {
    asm!(
        "out dx, al",
        in("dx") port,
        in("al") value,
        options(nomem, nostack, preserves_flags)
    );
}
```

**Input byte:**
```rust
unsafe fn inb(port: u16) -> u8 {
    let value: u8;
    asm!(
        "in al, dx",
        out("al") value,
        in("dx") port,
        options(nomem, nostack, preserves_flags)
    );
    value
}
```

**Assembly breakdown:**
```
out dx, al  ‚Üê Send byte in 'al' to port in 'dx'
in al, dx   ‚Üê Read byte from port in 'dx' into 'al'
```

---

## Common Issues

### Issue: Keyboard doesn't work
**Cause:** Forgot to send EOI
**Fix:** Always call `pic::send_eoi(1)` at end of handler

### Issue: Only one key works
**Cause:** Not sending EOI
**Fix:** Same as above

### Issue: Double characters
**Cause:** Not filtering key releases
**Fix:** Check `if scancode < 128`

### Issue: Kernel hangs
**Cause:** Interrupts not enabled
**Fix:** Call `idt::enable_interrupts()`

### Issue: Wrong characters
**Cause:** Scan code table is wrong
**Fix:** Verify SCANCODE_TO_ASCII table

---

## Testing

### Test 1: Basic Typing
```
Type: hello
Expected: "hello" appears on screen
```

### Test 2: Numbers
```
Type: 12345
Expected: "12345" appears on screen
```

### Test 3: Special Keys
```
Type: Enter key
Expected: Cursor moves to new line
```

### Test 4: Backspace
```
Type: abc, then backspace
Expected: Shows backspace character (or implement proper backspace)
```

---

## Improvements (Future)

### Current Limitations
- No Shift support (all lowercase)
- No Ctrl/Alt support
- Backspace doesn't actually delete
- No key repeat
- No Caps Lock indicator

### Future Features
1. **Shift/Caps Lock** - Track modifier keys
2. **Proper Backspace** - Delete previous character
3. **Key Buffer** - Store keys for programs to read
4. **Special Keys** - F1-F12, arrows, etc.
5. **Keyboard Layouts** - Support non-US keyboards

# Sources & Learning Resources

### Essential Reading:
1. **Multiboot Specification**
   - https://www.gnu.org/software/grub/manual/multiboot/multiboot.html
   - The official spec - read sections 3.1 and 3.2

2. **OSDev Wiki - Multiboot**
   - https://wiki.osdev.org/Multiboot
   - Practical examples and explanations

3. **OSDev Wiki - Bare Bones**
   - https://wiki.osdev.org/Bare_Bones
   - Complete minimal kernel tutorial

4. **GNU ld Manual - Linker Scripts**
   - https://sourceware.org/binutils/docs/ld/Scripts.html
   - Official documentation

5. **OSDev - Linker Scripts**
   - https://wiki.osdev.org/Linker_Scripts
   - Kernel-specific examples


### Assembly Learning:
1. **x86 Assembly Guide (Virginia)**
   - https://www.cs.virginia.edu/~evans/cs216/guides/x86.html
   - Excellent beginner-friendly introduction

2. **NASM Tutorial**
   - https://cs.lmu.edu/~ray/notes/nasmtutorial/
   - Learn NASM syntax specifically

3. **x86 Instruction Reference**
   - https://www.felixcloutier.com/x86/
   - Look up what any instruction does

### Deep Dives:
1. **Intel Software Developer Manuals**
   - https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html
   - The ultimate reference (very dense!)

2. **OSDev Wiki - Main Page**
   - https://wiki.osdev.org/
   - Browse for anything kernel-related

3. **How Computers Boot**
   - https://manybutfinite.com/post/how-computers-boot-up/
   - Understand the full boot process

4. **Linker Script Tutorial**
   - https://interrupt.memfault.com/blog/how-to-write-linker-scripts-for-firmware
   - Step-by-step guide

5. **GNU ld Examples**
   - https://sourceware.org/binutils/docs/ld/Simple-Example.html

### Rust OS
1. ***Writing an OS in Rust***
    -https://os.phil-opp.com/
    - how to create a x86_64 operating system in Rust